<div align="center">

<h1>Java虚拟机（Java Virtual Machine）</h1>

</div>

---

【多选题】以下哪些内存区域属于JVM规范？（　　）

A. 方法区

B. 实例变量

C. 静态变量

D. 程序计数器

E. 虚拟机栈

<details>
<summary> 查看答案</summary>

**正确答案：A D E**

知识点：

`Java` 虚拟机内存区域主要分为五个部分：程序计数器（ `PC` 寄存器）、虚拟机栈、本地方法栈、堆、方法区/元空间（包括常量池）。

| 内存区域          | 描述                                                                                         |
| ----------------- | -------------------------------------------------------------------------------------------- |
| **程序计数器**    | 记录当前线程执行的字节码行号指示器。每个线程都有独立的程序计数器。                           |
| **虚拟机栈**      | 用于存储局部变量和方法调用的信息。每个线程在执行Java方法时拥有对应的虚拟机栈。               |
| **本地方法栈**    | 与虚拟机栈类似，为本地（Native）方法服务，执行本地方法时使用。                               |
| **堆**            | 存储对象实例，被所有线程共享。垃圾回收主要针对堆进行。                                       |
| **方法区/元空间** | 存储类的结构信息、常量、静态变量等。在Java 8及之前称为"永久代"，在Java 8及之后称为"元空间"。 |

具体细节：

1. **程序计数器：**
   - 每个线程都有一个独立的程序计数器（ `PC` 寄存器）。
   - 记录当前线程执行的字节码行号指示器，也就是记录线程当前执行到哪条指令了。
   - 在多线程环境下，会切换执行不同线程的任务。

2. **虚拟机栈：**
   - 为每个线程分配一个虚拟机栈。
   - 存储局部变量、操作数栈、动态链接、方法出口等信息。
   - 栈帧（Stack Frame）：每个方法在执行时都会创建一个栈帧，栈帧包含方法的局部变量表和操作数栈等信息。

3. **本地方法栈：**
   - 与虚拟机栈类似，为执行本地方法服务。
   - 本地方法是用其他语言（如C语言）编写的方法，通过Java Native Interface（JNI）调用。

4. **堆：**
   - 存储对象实例，被所有线程共享。
   - 主要进行垃圾回收的区域，通过垃圾回收器管理内存。

5. **方法区/元空间：**
   - 存储类的结构信息、常量、静态变量等。
   - 在Java 8及之前称为"永久代"，在Java 8及之后称为"元空间"。
   - 在元空间中，类的元数据被存储在本地内存中，而不是堆中。

</details>

---

【单选题】下面有关`java classloader`说法错误的是？

A. Java默认提供的三个`ClassLoader`是 `BootStrap ClassLoader`，`Extension ClassLoader`，`App ClassLoader`

B. `ClassLoader`使用的是双亲委托模型来搜索类的

C. JVM在判定两个`class`是否相同时，只用判断类名相同即可，和类加载器无关

D. `ClassLoader`就是用来动态加载class文件到内存当中用的

<details>
<summary> 查看答案</summary>

**正确答案：C**

知识点：

`JVM`在判定两个`class`是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。

> 相关知识点：
>
>  **ClassLoader（类加载器）** 是Java虚拟机（JVM）的一个重要组件，负责将类的字节码加载到内存中，使得程序可以运行。ClassLoader的主要作用是在运行时查找和加载类文件，并生成相应的类对象。
>
> Java中的ClassLoader有一个层次结构，通过这个结构可以实现类加载的双亲委托模型。默认的ClassLoader层次结构包括：
> - `BootStrap ClassLoader`（启动类加载器）：负责加载Java的核心类库，通常用C++实现，是JVM的一部分，无法直接在Java代码中获取。
> - `Extension ClassLoader`（扩展类加载器）：负责加载Java的扩展类库。
> - `App ClassLoader`（应用程序类加载器）：负责加载应用程序的类，是程序中默认的ClassLoader。
>
>  **双亲委托模型** ： ClassLoader采用双亲委托模型，即在加载类的时候，会首先委托父类加载器加载。如果父类加载器无法加载，才由子类加载器加载。这个机制保证了类的加载顺序和一致性，防止类的重复加载。
>
>   **类加载的触发时机**： 类加载是在程序运行时动态进行的，而不是在编译时。类加载的触发时机包括：
> 1. 当程序创建类的实例时。
> 2. 当程序访问类的静态变量或静态方法时。
> 3. 当程序使用反射机制操作类时。
> 4. 当程序初始化一个类的子类时。


</details>


<!-- <details>
<summary> 查看答案</summary>

**正确答案：**

知识点：



</details> -->